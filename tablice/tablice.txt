const arr = [1,2,3,4,5,6]


mogą być różne typy danych 
w htm mam <button>
gdy w js napiszę :
const btn1 = document.querySelector('button') <- weźmie mi do btn1 pierwszy napotkany button


gdy napiszę const btns = document.querySelectorAll('button')
zwróci mi obiekt tablicopodobny zawierający wszystkie buttony 



btns.forEach() <- pętla, która przejdzie po całej naszej tablicy i dla 
każdego elementu daną funkcję / pewien kod

--------
metody 

array.unshift(100, 200)  <- dodaje na początku tablicy liczby 100 i 200

array.shift() <- usuwa pierwszy element 

array.pop()   <- usuwa ostatni element z tablicy

array.push('5') <- dodaje element na koniec tablicy 

function multiply(x) {
  return x*2
}

const newNumbers = numbers.map(multiply)  <- bierze tablicę, iteruje i stosuje podaną funkcję, 
					na każdym elemencie i zapisuje go w nowej tablicy, którą zwraca
console.log(numbers)
console.log(newNumbers)

numbers.push(6, 7, 8)  <- jest to metoda destrukcyjna, ponieważ zmienia nasze pierwotne dane !!!

niedestrukcyjnym dodanie jest concat

const abc = ['a', 'b', 'c']
const newAbc = numbers.concat(abc)

console.log(newAbc)

wszystko można dodać, nie koniecznie tablicę
const newAbc = numbers.concat(1,4,6, true, abc)

-------------
... rest, spread

console.log(...abc) <- zwraca osobne stringi  <- rozsmarowywuje elementy (nie do końca to rozumiem)

const drinks = ['pepsi', 'kawa', 'sok']
const meals = ['schabowy', 'spaghetti', 'zupa']

dwa sposoby łączenia tablic :
const menu = [...drinks, ...meals]
const menu2 = drinks.concat(meals)

console.log(menu)
console.log(menu2)
--------
metody slice () ans splice() 

slice()
- metoda niedestrukcyjna
slice(1,3) < - 1 arg czyli u nas 1 jest to indeks el. od którego wycinamy, 
		2 arg to inkedks el. do którego wycinamy

!!jeżeli wycinamy od pierwszego arg to jest to 1 (nie 0)
czyli np. slice(2) wycina daw pierwsze
slice(2,4) wycina indeks 2 i 3, bez 4

slice(-2) zwraca dwa ostatnie 


splice()
- metoda destrukcyjna
slice(1,3, 6) < - 1 arg czyli u nas 1 jest to indeks el. od którego wycinamy, 
		2 arg to inkedks el. do którego wycinamy
		3 arg to nowy element, ktory chcemy dodać do tablicy


filter() <- filtruje i zwraca tablicę elementów tylko spełniających wymagania
funkcja ma callback'a 

callback - funkcja, którą przekazujemy jako argument do innej funkcji

const numbers = [0, 23, 48, 175, 2, 34, 11]

function number(x) {
  return x % 2 === 0
}

console.log(numbers.filter(number))
w consoli:
Array(4) [ 0, 48, 2, 34 ]

numbers.forEach(number => console.log(number * 5))

includes()
console.log(numbers.includes('0'))

console.log(numbers.indexOf(23))
zwraca index

jeżeli zwróci -1 oznacza to, że tablica nie przechowuje tego elementu.

------------
maps i forEach <- wrócić do tego odcinka w przyszłości <- po zakoczeniu kursu

metoda forEach nic nie zwraca (undefined)

const NewNumbers = numbers.forEach(number => console.log(number * 2))
const newNumbers = numbers.map(number => (number * 2))
console.log(newNumbers)

UWAŻAĆ NA CONSOLE.LOG <- jak będzie wywolany w funckji to zwróci mi array of 4 undefined in that case

forEach jest fajny na listening (nasłuchiwanie) czy użytkownik kliknął to co nas interesuje






